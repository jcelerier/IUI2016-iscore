\documentclass{sigchi}

% Use this command to override the default ACM copyright statement (e.g. for preprints). 
% Consult the conference website for the camera-ready copyright statement.


%% EXAMPLE BEGIN -- HOW TO OVERRIDE THE DEFAULT COPYRIGHT STRIP -- (July 22, 2013 - Paul Baumann)
% \toappear{Permission to make digital or hard copies of all or part of this work for personal or classroom use is 	granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. \\
% {\emph{CHI'14}}, April 26--May 1, 2014, Toronto, Canada. \\
% Copyright \copyright~2014 ACM ISBN/14/04...\$15.00. \\
% DOI string from ACM form confirmation}
%% EXAMPLE END -- HOW TO OVERRIDE THE DEFAULT COPYRIGHT STRIP -- (July 22, 2013 - Paul Baumann)


% Arabic page numbers for submission. 
% Remove this line to eliminate page numbers for the camera ready copy
% \pagenumbering{arabic}


% Load basic packages
\usepackage{balance}  % to better equalize the last page
\usepackage{graphics} % for EPS, load graphicx instead
\usepackage{times}    % comment if you want LaTeX's default font
\usepackage{url}      % llt: nicely formatted URLs
\usepackage{listings}
% llt: Define a global style for URLs, rather that the default one
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\bf\ttfamily}}}
\makeatother
\urlstyle{leo}


% To make various LaTeX processors do the right thing with page size.
\def\pprw{8.5in}
\def\pprh{11in}
\special{papersize=\pprw,\pprh}
\setlength{\paperwidth}{\pprw}
\setlength{\paperheight}{\pprh}
\setlength{\pdfpagewidth}{\pprw}
\setlength{\pdfpageheight}{\pprh}

% Make sure hyperref comes last of your loaded packages, 
% to give it a fighting chance of not being over-written, 
% since its job is to redefine many LaTeX commands.
\usepackage[pdftex]{hyperref}
\hypersetup{
pdftitle={SIGCHI Conference Proceedings Format},
pdfauthor={LaTeX},
pdfkeywords={SIGCHI, proceedings, archival format},
bookmarksnumbered,
pdfstartview={FitH},
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black,
breaklinks=true,
}

% create a shortcut to typeset table headings
\newcommand\tabhead[1]{\small\textbf{#1}}


% End of preamble. Here it comes the document.
\begin{document}

\title{Graphical Structured Temporal Programming for Interactive Applications}

\numberofauthors{3}
\author{
  \alignauthor 1st Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
    \affaddr{Optional phone number}
  \alignauthor 2nd Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
    \affaddr{Optional phone number}    
  \alignauthor 3rd Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
    \affaddr{Optional phone number}
}

\maketitle

\begin{abstract}
  The development of interactive shows and interactive user interfaces for arts \& exhibitions
has traditionally been done with tools that pertain to two broad metaphors. 
Cue-based environments work by making groups of parameters and sending them to remote devices, 
while more interactive applications are generally written in domain-specific 
programming environments, like Max/MSP, Processing or OpenFrameworks.
  In this paper, we argue about the specific issues that arise in such environments, and we present 
i-score : an extensive and collaborative software suite that bridges
the gap between time-based, logic-based and flow-based interactive application authoring tools. 
This is done in a single cohesive graphical user interface, built upon a few simple and novel primitives.
  i-score allows the creation of software meant for operation in a large parameter space, 
and enables artists to express easily both temporal logic and structured programming, 
with facilities for automating and applying transformations to single and multi-dimensional parameters.
\end{abstract}

\keywords{
	Guides; instructions; author's kit; conference publications;
	keywords should be separated by a semi-colon. \newline
	\textcolor{red}{Optional section to be included in your final version, 
  but strongly encouraged.}
}

\category{H.5.m.}{Information Interfaces and Presentation (e.g. HCI)}{Miscellaneous}

See: \url{http://www.acm.org/about/class/1998/}
for more information and the full list of ACM classifiers
and descriptors. \newline
\textcolor{red}{Optional section to be included in your final version, 
but strongly encouraged. On the submission page only the classifiers’ 
letter-number combination will need to be entered.}

\section{Introduction}
This paper presents a paradigm that aims to allow non-programmers 
to conceive interactive applications easily and execute them in production.

The existing software stack is either oriented too much towards the 
cue paradigm, which is useful as long as there is no complex logic involved, 
or towards the programming paradigm, where it is hard to write simple scenarios 
like "move a spotlight in horizontal oscillation for ten seconds; after the first 5 
seconds, if a dancer jumps on the stage, play a sound and increase reverberation steadily as long as the dancer is on stage".

We will first present the current practices on the field, including the depiction of three specific artistic installations revolving around the idea of a computer-controlled orchestration.

We will then explain the paradigm of the i-score software, which allows to express complex scenarios in a single graphical interface. These scenarios can then be deported or even embedded in other tools thanks to a C++ API. 
\subsection{Motivation}
The need for authoring software able to operate in both the temporal and logical domains arises as soon as an artist wants to set-up a show which may have different outcomes according to the actions of the performer, or even of the participants.

\subsection{Use cases}
To explain properly the kind of artistic demeanors we are working with, there will be three case studies.

\paragraph{The Drop}
\paragraph{Stockhausen, Klavierstucke XI}
\paragraph{The Runner}
This is an actual museum installation that is located in the Futuroscope, at the city of Poitiers in France.

\subsection{Existing approaches}

\subsubsection{Content creation}
Flash, Processing, OF, domain-specific software...

\subsubsection{Flow control models}
 % du tout temporel au tout logique en passant par systèmes réactifs ?
Max, PureData, React.[...], Integra Live (qui est plutôt orienté son), Unity \& envs de jeu, etc. (revoir slides), Chronic (cf. téléchargements), OpenMusic, Antescofo (et Ascograph), logiciels de la conférence sur appli réactives (cf. slack).

\subsubsection{Document models and application description} % bof ici
CORBA, DBus, DOM HTML, DOM Qt, DOM Jamoma...


\section{A model for orchestration}
We will present our constructs by starting with the purely temporal ones, 
and then extend to the constructs relevant in a structured programming context.
Finally we will see how data is handled.

This model has evolved through many stages of refinement, first starting as an application of 
Allen's relationships and moving on to NTCCs, Petri nets, finite automatons, and reactive languages.

\subsection{Specification of temporal relationships}\label{sec.temporal}
The first required primitive is the one able to depict a duration.

We shall call it a time constraint.

The time constraint is not necessarily a fixed duration : to allow for interactiveness, 
we must allow it to represent a range, or span of time. For instance, a time constraint may last between 3 and 5 seconds.

Then, we introduce a mean to synchronize multiple time constraints : a time node. 

This allows multiple time constraints to exist both serially, and in parallel. 


\subsection{Structured temporal programming}
Maintenant que nous avons des primitives permettant de décrire l'écoulement du temps, nous introduisons les éléments s'apparentant à la programmation structurée.

La base est la conditionnelle. Dans notre cas, nous aimerions dire : cette contrainte temporelle ne s'exécute que si tel paramètre a atteint cette valeur.

Du fait de la présence de logique temporelle, il y a deux cas de conditions : 
- Les conditions qui ne prennent pas le temps en compte. Elles sont vraies ou fausses, et la chose qui compte est leur valeur au moment ou elles seront évaluées. Elles n'ont d'influence que sur le futur.
- Les conditions qui contrôlent le flot du temps. Elles ont le pouvoir de déclencher des intervalles lorsqu'elles passent à vrai. C'est pour cela que nous avons besoin d'avoir un minimum et un maximum à nos contraintes temporelles. Elles ont donc aussi une influence sur des contraintes temporelles précédentes : on dirait par exemple : "cette contrainte dure *jusqu'à ce que la condition soit vraie". On peut ainsi faire durer une contrainte à l'infini en mettant une condition "faux". Ceci permet d'écrire des applications avec un fonctionnement "moteur", qui ne sont pas sensées s'arrêter.

Nous séparons ces deux cas en deux éléments de syntaxe de notre langage : l'évènement pour le premier, et le trigger pour le second.

Les deux font interface entre les contraintes et les noeuds temporels.

À partir de là, nous pouvons considérer la notion de boucle. Pour cela, il est nécessaire de bien clarifier la séparation entre les données spécifiées par l'auteur, et le résultat de l'exécution.

Quand un auteur ou programmeur spécifie une boucle, il décrit un motif général qui est voué à être répété. Cependant, à chaque itération des cas différents peuvent arriver : 

\begin{lstlisting}
while t < 100
  if a
    [...] short iteration [...]
  else
    [...] long iteration [...]           
\end{lstlisting}

Dans notre cas, nous avons donc besoin d'une contrainte souple pour pouvoir avoir des boucles intéressantes. 

On décrit donc la boucle comme une paire (noeud temporel, contrainte). La contrainte est des deux côtés du noeud temporel : une fois qu'elle a été lue, elle peut être re-lue depuis le début, sachant que l'on progresse dans l'écoulement du temps.


\section{From structure to content}
Maintenant que nous avons établi l'intégralité des éléments nécessaires à une structuration logique et temporelle, nous nous intéressons aux données.

Comme cela a pu être vu en section~\ref{sec.temporal}, nous possédons deux primitives temporelles : une pour les durées et une pour les instants.

Il y a deux points de vue possibles : le premier est que le temps doit être traité comme un continuum : un instant n'a pas d'existence propre et on ne peut que l'approcher comme on approcherait un élément dans un ensemble dense. Ceci permet de raisonner simplement sur des problématiques de positionnement d'éléments par rapport au temps.

Néanmoins, il est parfois utile de briser l'abstraction et d'obtenir le contrôle bas niveau : dans des logiciels audio, c'est par exemple le cas de l'accès à la sample.

Le type de données avec lequel i-score est le plus utilisé est le message OSC. Là aussi, il est nécessaire d'avoir un accès précis au comportement qui s'applique lorsque par exemple, deux courbes se suivent et portent sur la même adresse sans que la fin de la première courbe ait la même valeur que le début de la suivante. Veut-on privilégier une valeur ? Utiliser les deux ? L'utilisateur doit avoir le choix de la valeur envoyée lorsqu'il y a une discrepancy manifeste entre un instant logique dans le scénario, et un instant physique, ordonné par l'horloge d'une carte son ou du cpu.
- Processus
- Hiérarchie (qu'on a déjà présenté).

- Paramètres : actuellement, scope global
Puis scope local dans la hiérarchie ?

- Arbre local de paramètres : 
=> influences pour boucles : on peut faire des boucles auto-dépendantes car on a accès au temps.
-> parler des différentes possibilités que ça ouvre : 
* Canons
* Fractales
* etc..
-> rejoint la programmation structurée via les données

Perspective : transformations appliquées à une boîte

- Questions de synchronisation d'états (avant / pendant / après)

- Passage de messages pour contrôle interne ou externe

- Automations  

- Mappings 1D

- Mappings n-D

- Conclusion : analogue à un petit OS spécialisé pour applications multimédia.

\section{Shortcomings (et pistes)}
\subsection{Debugging}
- Getting execution traces
-> How to go at any point in the flow of a software ? The external state might not be correct.
(Conoundrum of "instant debugging" but requiring for instance a smoke machine to spit smoke for ten minutes)

- Visualisation / simulation du résultat ? 

\section{Evaluation}
- Time to develop artistic installations greatly reduced.

\section{Conclusion}
%% Logiciel ouvert et utilisable (API C++)
%% Perspectives : autres implémentations (FPGA, kdbus, modèle de calcul ?)

\end{document}
