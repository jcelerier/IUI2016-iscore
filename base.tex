\documentclass{sigchi}

% Use this command to override the default ACM copyright statement (e.g. for preprints). 
% Consult the conference website for the camera-ready copyright statement.


%% EXAMPLE BEGIN -- HOW TO OVERRIDE THE DEFAULT COPYRIGHT STRIP -- (July 22, 2013 - Paul Baumann)
% \toappear{Permission to make digital or hard copies of all or part of this work for personal or classroom use is 	granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. \\
% {\emph{CHI'14}}, April 26--May 1, 2014, Toronto, Canada. \\
% Copyright \copyright~2014 ACM ISBN/14/04...\$15.00. \\
% DOI string from ACM form confirmation}
%% EXAMPLE END -- HOW TO OVERRIDE THE DEFAULT COPYRIGHT STRIP -- (July 22, 2013 - Paul Baumann)


% Arabic page numbers for submission. 
% Remove this line to eliminate page numbers for the camera ready copy
% \pagenumbering{arabic}


% Load basic packages
\usepackage{balance}  % to better equalize the last page
\usepackage{graphics} % for EPS, load graphicx instead
\usepackage{times}    % comment if you want LaTeX's default font
\usepackage{url}      % llt: nicely formatted URLs
\usepackage{listings}
% llt: Define a global style for URLs, rather that the default one
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\bf\ttfamily}}}
\makeatother
\urlstyle{leo}


% To make various LaTeX processors do the right thing with page size.
\def\pprw{8.5in}
\def\pprh{11in}
\special{papersize=\pprw,\pprh}
\setlength{\paperwidth}{\pprw}
\setlength{\paperheight}{\pprh}
\setlength{\pdfpagewidth}{\pprw}
\setlength{\pdfpageheight}{\pprh}

% Make sure hyperref comes last of your loaded packages, 
% to give it a fighting chance of not being over-written, 
% since its job is to redefine many LaTeX commands.
\usepackage[pdftex]{hyperref}
\hypersetup{
pdftitle={SIGCHI Conference Proceedings Format},
pdfauthor={LaTeX},
pdfkeywords={SIGCHI, proceedings, archival format},
bookmarksnumbered,
pdfstartview={FitH},
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black,
breaklinks=true,
}

% create a shortcut to typeset table headings
\newcommand\tabhead[1]{\small\textbf{#1}}


% End of preamble. Here it comes the document.
\begin{document}

\title{Graphical Structured Temporal Programming for Interactive Applications}

\numberofauthors{3}
\author{
  \alignauthor 1st Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
    \affaddr{Optional phone number}
  \alignauthor 2nd Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
    \affaddr{Optional phone number}    
  \alignauthor 3rd Author Name\\
    \affaddr{Affiliation}\\
    \affaddr{Address}\\
    \email{e-mail address}\\
    \affaddr{Optional phone number}
}

\maketitle

\begin{abstract}
  The development of interactive shows and interactive user interfaces for arts \& exhibitions
has traditionally been done with tools that pertain to two broad metaphors. 
Cue-based environments work by making groups of parameters and sending them to remote devices, 
while more interactive applications are generally written in domain-specific 
programming environments, like Max/MSP, Processing or OpenFrameworks.
  In this paper, we argue about the specific issues that arise in such environments, and we present 
i-score : an extensive and collaborative software suite that bridges
the gap between time-based, logic-based and flow-based interactive application authoring tools. 
This is done in a single cohesive graphical user interface, built upon a few simple and novel primitives.
  i-score allows the creation of software meant for operation in a large parameter space, 
and enables artists to express easily both temporal logic and structured programming, 
with facilities for automating and applying transformations to single and multi-dimensional parameters.
\end{abstract}

\keywords{
	Guides; instructions; author's kit; conference publications;
	keywords should be separated by a semi-colon. \newline
	\textcolor{red}{Optional section to be included in your final version, 
  but strongly encouraged.}
}

\category{H.5.m.}{Information Interfaces and Presentation (e.g. HCI)}{Miscellaneous}

See: \url{http://www.acm.org/about/class/1998/}
for more information and the full list of ACM classifiers
and descriptors. \newline
\textcolor{red}{Optional section to be included in your final version, 
but strongly encouraged. On the submission page only the classifiers’ 
letter-number combination will need to be entered.}

\section{Introduction}
This paper presents a paradigm that aims to allow non-programmers 
to conceive interactive applications easily and execute them in production.

The existing software stack is either oriented too much towards the 
cue paradigm, which is useful as long as there is no complex logic involved, 
or towards the programming paradigm, where it is hard to write simple scenarios 
like "move a spotlight in horizontal oscillation for ten seconds; after the first 5 
seconds, if a dancer jumps on the stage, play a sound and increase reverberation steadily as long as the dancer is on stage".

We will first present the current practices on the field, including the depiction of three specific artistic installations revolving around the idea of a computer-controlled orchestration.

We will then explain the paradigm of the i-score software, which allows to express complex scenarios in a single graphical interface. These scenarios can then be deported or even embedded in other tools thanks to a C++ API. 
\subsection{Motivation}
The need for authoring software able to operate in both the temporal and logical domains arises as soon as an artist wants to set-up a show which may have different outcomes according to the actions of the performer, or even of the participants.

\subsection{Use cases}
To explain properly the kind of artistic demeanors we are working with, there will be three case studies.

\paragraph{The Drop}
\paragraph{Stockhausen, Klavierstucke XI}
\paragraph{The Runner}
This is an actual museum installation that is located in the Futuroscope, at the city of Poitiers in France.

\subsection{Existing approaches}

\subsubsection{Content creation}
Flash, Processing, OF, domain-specific software...

\subsubsection{Flow control models}
 % du tout temporel au tout logique en passant par systèmes réactifs ?
Max, PureData, React.[...], Integra Live (qui est plutôt orienté son), Unity \& envs de jeu, etc. (revoir slides), Chronic (cf. téléchargements), OpenMusic, Antescofo (et Ascograph), logiciels de la conférence sur appli réactives (cf. slack).

\subsubsection{Document models and application description} % bof ici
CORBA, DBus, DOM HTML, DOM Qt, DOM Jamoma...


\section{A model for orchestration}
We will present our constructs by starting with the purely temporal ones, 
and then extend to the constructs relevant in a structured programming context.
Finally we will see how data is handled.

This model has evolved through many stages of refinement, first starting as an application of 
Allen's relationships and moving on to NTCCs, Petri nets, finite automatons, and reactive languages.

\subsection{Specification of temporal relationships}\label{sec.temporal}
The first required primitive is the one able to depict a duration.

We shall call it a time constraint.

The time constraint is not necessarily a fixed duration : to allow for interactiveness, 
we must allow it to represent a range, or span of time. For instance, a time constraint may last between 3 and 5 seconds.

Then, we introduce a mean to synchronize multiple time constraints : a time node. 

This allows multiple time constraints to exist both serially, and in parallel. 


\subsection{Structured temporal programming}
Maintenant que nous avons des primitives permettant de décrire l'écoulement du temps, nous introduisons les éléments s'apparentant à la programmation structurée.

La base est la conditionnelle. Dans notre cas, nous aimerions dire : cette contrainte temporelle ne s'exécute que si tel paramètre a atteint cette valeur.

Du fait de la présence de logique temporelle, il y a deux cas de conditions : 
- Les conditions qui ne prennent pas le temps en compte. Elles sont vraies ou fausses, et la chose qui compte est leur valeur au moment ou elles seront évaluées. Elles n'ont d'influence que sur le futur.
- Les conditions qui contrôlent le flot du temps. Elles ont le pouvoir de déclencher des intervalles lorsqu'elles passent à vrai. C'est pour cela que nous avons besoin d'avoir un minimum et un maximum à nos contraintes temporelles. Elles ont donc aussi une influence sur des contraintes temporelles précédentes : on dirait par exemple : "cette contrainte dure *jusqu'à ce que la condition soit vraie". On peut ainsi faire durer une contrainte à l'infini en mettant une condition "faux". Ceci permet d'écrire des applications avec un fonctionnement "moteur", qui ne sont pas sensées s'arrêter.

Nous séparons ces deux cas en deux éléments de syntaxe de notre langage : l'évènement pour le premier, et le trigger pour le second.

Les deux font interface entre les contraintes et les noeuds temporels.

À partir de là, nous pouvons considérer la notion de boucle. Pour cela, il est nécessaire de bien clarifier la séparation entre les données spécifiées par l'auteur, et le résultat de l'exécution.

Quand un auteur ou programmeur spécifie une boucle, il décrit un motif général qui est voué à être répété. Cependant, à chaque itération des cas différents peuvent arriver : 

\begin{lstlisting}
while t < 100
  if a
    [...] short iteration [...]
  else
    [...] long iteration [...]           
\end{lstlisting}

Dans notre cas, nous avons donc besoin d'une contrainte souple pour pouvoir avoir des boucles intéressantes. 

On décrit donc la boucle comme une paire (noeud temporel, contrainte). La contrainte est des deux côtés du noeud temporel : une fois qu'elle a été lue, elle peut être re-lue depuis le début, sachant que l'on progresse dans l'écoulement du temps.


\section{From structure to content}
Maintenant que nous avons établi l'intégralité des éléments nécessaires à une structuration logique et temporelle, nous nous intéressons aux données.

Comme cela a pu être vu en section~\ref{sec.temporal}, nous possédons deux primitives temporelles : une pour les durées et une pour les instants.

Il y a deux points de vue possibles : le premier est que le temps doit être traité comme un continuum : un instant n'a pas d'existence propre et on ne peut que l'approcher comme on approcherait un élément dans un ensemble dense. Ceci permet de raisonner simplement sur des problématiques de positionnement d'éléments par rapport au temps.

Néanmoins, il est parfois utile de briser l'abstraction et d'obtenir le contrôle bas niveau : dans des logiciels audio, c'est par exemple le cas de l'accès à la sample.

Le type de données avec lequel i-score est le plus utilisé est le message OSC. Là aussi, il est nécessaire d'avoir un accès précis au comportement qui s'applique lorsque par exemple, deux courbes se suivent et portent sur la même adresse sans que la fin de la première courbe ait la même valeur que le début de la suivante. Veut-on privilégier une valeur ? Utiliser les deux ? L'utilisateur doit avoir le choix de la valeur envoyée lorsqu'il y a une discrepancy manifeste entre un instant logique dans le scénario, et un instant physique, ordonné par l'horloge d'une carte son ou du cpu.

Dans le logiciel, le type de données que nous manipulons le plus est donc le message, qui associe une valeur à une addresse. Plusieurs messages regroupés forment un état, par analogie avec les cues.

- Processus
Pour encapsuler ces données, dans le cadre d'une durée nous choisissons principalement la métaphore du processus. Une contrainte peut contenir un nombre arbitraire de processus; l'interface d'un processus est très simple et permet de décrire des cas complexes. Elle est analogue à un système de passage de messages.

\begin{lstlisting}
    interface Process {
       State state(Time)
    }
\end{lstlisting}

Cea permet à la contrainte de fonctionner de la même manière qu'une tête de lecture : une horloge va envoyer des ticks; à chaque tick le processus doit renvoyer son état. Ce fonctionnement semble fonctionnel pur mais rien n'empêche d'avoir des effets de bord / sauvegarder un état.
Sur un plan théorique (et au niveau de l'exécution) un processus peut être vu comme une succession d'états, néanmoins ce serait une abstraction difficile à manier pour l'auteur, notamment en ce qui concerne les automations.

Il convient donc de noter que les processus peuvent s'arrêter avant leur fin apparente, si par exemple il y a un trigger sur la fin de la contrainte.

Problème des contraintes à l'édition / à l'exécution : certains arguent que tout devrait être souple à l'exécution et rien à l'édition; d'autre le contraire. D'ou plusieurs modes d'édition grâce à un CSP.

- États
Les processus ont un sens sur une durée. Cependant, il existe aussi le cas ou nous voudrions envoyer des données à un instant précis : par exemple, pour lancer la lecture d'un média distant.
Pour ce faire, i-score matérialise la notion d'état instantané dans un élément graphique.

Les états sont situés au début et à la fin de chaque contrainte temporelle. Cela permet de spécifier très simplement des interpolations entre deux paramètres, en prenant une capture d'un premier état puis d'un second.

Nous avons donc l'ensemble des éléments de base qui composent ce que l'on nomme un scénario : en reliant contraintes, évènements, états, triggers et noeuds temporels nous pouvons déjà définir ces scénarios complexes, mais linéaires.

- Hiérarchie (qu'on a déjà présenté).
À l'aide de la notion de processus, nous pouvons introduire le concept de hiérarchie. La notion de scénario que nous avons présenté peut être placée dans un processus, qui aura comme spécificité d'avoir un noeud temporel de début. Ainsi, son état peut être récupéré récursivement à chaque instant en fonction des appels du parent.

Par défaut, un document est constitué de deux noeuds temporels, et d'une contrainte intermédiaire qui contient un processus Scénario.
Il aurait été possible d'avoir le cas inverse : l'élément de base aurait pu être un processus scénario dans lequel on commencerait à travailler; cependant avoir une contrainte comme élément parent permet de contrôler la vitesse de lecture globale de manière interne au formalisme. De même, on peut faire "lecture" sur le document en envoyant des messages OSC au noeud temporel de début.

- De même, la boucle est implémentée en terme de processus.

- Précision sur les états
Les états se réfèrent la plupart du temps à des périphériques distants : d'autres logiciels compatibles OSC comme Max/MSP ou PureData, ou bien des appareils MIDI.

L'accès se fait via une interface commune, organisée sous forme d'arbre.

En effet, cela permet de représenter simplement les DOM courants.

% Mettre capture d'écran d'un objet Qt ?

Cette interface peut être simplement réimplémentée. Cependant il faut tenir compte du fait que tous les protocoles n'offrent pas les mêmes capacités : par exemple un arbre MIDI est entièrement fixe car les messages sont fixés dans la spécification MIDI. En revanche un arbre qui correspondrait à un logiciel écrit en Max/MSP serait beaucoup plus dynamique.

Les paramètres présents dans cet arbre peuvent ensuite être accédés depuis tout le logiciel.

Pour l'instant, ils sont donc organisés sous forme d'état global, à l'image d'une base de données. Cependant nous aimerions évoluer vers un état avec une portée locale, peut-être avec un raffinement au niveau des processus (Processus "LocalScope"). Cela rejoindrait le concept d'unité de données de la programmation structurée.

De plus, le scénario présente lui aussi son propre arbre de paramètres, addressable depuis l'intérieur comme l'extérieur.

Cela permet notamment de se référer au temps qui s'est écoulé à l'exécution pour s'en reservir dans d'autres contraintes.

Cela permet par exemple de faire des boucles à durée convergente, des canons, et des systèmes en forme de fractale. % donner exemple


-> opérateurs ? et =

Perspective : transformations appliquées à une boîte

- Questions de synchronisation d'états (avant / pendant / après)

- Passage de messages pour contrôle interne ou externe

- Automations  

- Mappings 1D

- Mappings n-D

- Conclusion : analogue à un petit OS spécialisé pour applications multimédia.

\section{Shortcomings (et pistes)}
\subsection{Debugging}
- Getting execution traces
-> How to go at any point in the flow of a software ? The external state might not be correct.
(Conoundrum of "instant debugging" but requiring for instance a smoke machine to spit smoke for ten minutes)

- Visualisation / simulation du résultat ? 

\section{Evaluation}
- Time to develop artistic installations greatly reduced.

\section{Conclusion}
%% Logiciel ouvert et utilisable (API C++)
%% Perspectives : autres implémentations (FPGA, kdbus, modèle de calcul ?)

\end{document}
